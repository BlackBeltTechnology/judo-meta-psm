JUDO Tatami PSM Archetype maven plugin
======================================

This plugin manages and executes generators for JUDO PSM models.

It generates text based codes / reports from PSM model with the given templates.

== Requirements

- Maven 3.8.3 and Java 11

== Installation

Include the plugin as a dependency in your Maven project. Change `LATEST_VERSION` to the latest tagged version.

```
<plugin>
    <groupId>hu.blackbelt.judo.archetype</groupId>
	<artifactId>judo-psm-archetype-maven-plugin</artifactId>
    <version>LATEST_VERSION</version>
    ...
</plugin>
...

```

== Usage

Executing a template for an PSM model

```

<plugin>
    <groupId>hu.blackbelt.judo.archetype</groupId>
    <artifactId>judo-psm-archetype-maven-plugin</artifactId>
    <version>${judo-psm-archetype-version}</version>
    <executions>
        <execution>
            <id>execute-psm-test-model-from-artifact</id>
            <phase>test</phase>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <psm> <!-- 1 -->
                    mvn:hu.blackbelt.judo.tatami:judo-tatami-northwind-psm:${judo-tatami-version}!model/northwind-psm.model
                </psm>
                <uris> <!-- 2 -->
                    <uri>mvn:hu.blackbelt.judo.archetype:judo-psm-fullstack-project-archetype:${judo-psm-fullstack-project-archetype-version}</uri>
                    <uri>${basedir}/src/main/resources</uri>
                </uris>
                <helpers> <!-- 3 -->
                    <helper>hu.blackbelt.judo.psm.fullstack.project.archetype.PsmProjectHelper</helper>
                </helpers>
                <type>fullstack-project</type> <!-- 4 -->
                <destination>${basedir}/target/test-classes/psm/artifact</destination> <!-- 5 -->
                <templateParameters> <!-- 6 -->
                    <judoPlatformVersion>${judo-platform-version}</judoPlatformVersion>
                </templateParameters>
                <contextAccessor>hu.blackbelt.judo.psm.fullstack.project.archetype.ActorTypeValueResolver</contextAccessor> <!-- 7 -->
                <scanDependencies>true</scanDependencies> <!-- 8 -->
                <actors></actors> <!-- 9 -->
            </configuration>
        </execution>
    </executions>

    <dependencies>
        <dependency>
            <groupId>hu.blackbelt.judo.meta</groupId>
            <artifactId>hu.blackbelt.judo.meta.psm.model.northwind</artifactId>
            <version>${judo-meta-psm-version}</version>
        </dependency>

        <dependency>
            <groupId>hu.blackbelt.judo.meta</groupId>
            <artifactId>hu.blackbelt.judo.meta.psm.model.northwind</artifactId>
            <version>${judo-meta-psm-version}</version>
        </dependency>

    </dependencies>
</plugin>

```

In the parameter URI type parameters can be file or mvn with the following coordinate:
`mvn:<groupId>:<artifactId>[:<extension>[:<classifier>]]:<version>[!path/in/archive]`

<1> PSM model URI. (Optional)

<2> Template URIs. The templates loaded from URI's. The order is reverse, first try to load from last URI, when the resource
not found there step back to previous defined URI. So it's a layered loader, where the templates can be extended and
overrided with other template packages.

<3> Helper classes. It contains methods which can be used in SpringEL (project yaml definition expressions) and in the
handlebars templates. The helper classes can be loaded from plugin's classloaders, so the helper's class can
be presented in plugin's or the project's dependencies. When a helper implements the `com.github.jknack.handlebars.ValueResolver`
interface automatically registered as a handlebar value resolver. When `scanDependencies` parameter is `true`, the scanned
helpers and the given ones are merged.

<4> Project type. It is used to resolve the project descriptor yaml files. The yaml file name is `<project type>-project.yam;`.
One template can countains several project type description, so same templates can be used for multiple project skeleton types.

<5> Destination path where the transformation output is generated. When no actor or more than one actor is defined, for all actors
different folder generated by name. Default: ${project.basedir}/target/classes/model.

<6> Template parameters. The defined parameters here can be accessed in SpringEL and handlebars
templates with the same name.

<7> ContextAccessor. It can be used to store Handlebars / SpringEL / Parameters Context which can be accessed by type resolvers.
When `scanDependencies` value is `true`, the classes annotated with `@hu.blackbelt.judo.generator.commons.annotations.ContextAccessor` are
set as accessor. When multiple instances are presented, error is thrown.
It can implement any of the following methods, depends on which context can be registered:
- `public static void bindContext(com.github.jknack.handlebars.Context)` Register handlebars context. It is called immediately before templating,
   so it is not recommended to use to calculate factory or path values with it.
- `public static void bindContext(org.springframework.expression.spel.support.StandardEvaluationContext context)` It registers
   Spring Expression Language context. It is called before any templating, it can be used in yaml and template context too.
- `public static void bindContext(java.util.Map<String, Object> parameters`)
   It is registers the given external parameters. It is called before any templating, it can be used in yaml and template context too.

<8> Scan dependencies. It scans classpath for classes annotated with `@hu.blackbelt.judo.generator.commons.annotations.TemplateHelper` and
`@hu.blackbelt.judo.generator.commons.annotations.ContextAccessor` annotated classes.

<9> Actors used to generation. When it is not set all actors are generated. To define use coma separated fully qualified name of actor class.

Recommended to store the context in ThreadLocal, because
templating is running in multiple threads.


== Generation

For code generation handlebars template is used. The `<project type>-project.yaml` file
describes what template is used for that and control which parameters
are passed and PSM model can control HOW the templates can be used.

== Override templates in generation

The template override can contain a `<project type>-project.yaml` which can be empty, on that case the
existing templates can be overrided only. The content of project file is used to override existing
template definition or can be added new templates. The ovirrided preferences reverse ordered, so the last defined override is the strongest.
All of the templates can be decorated, when the original file name is suffixed with `override.hbs`. When it is
defined the original one can be included with the standard fragment syntax of handlebars.

=== Example:
To decorate `file_for_actor.test.hbs,` put `file_for_actor.test.override.hbs` file. The original content can be referenced:

```
The original content:
{{> lib/file_for_actor.test.hbs }}
```

== <project type>-project.yaml file

This file is used to control generation process. This file is using the PSM model and the given helpers.

For expression processing, the SpringEL expression language is used. The helpers are binded as
handlebars helper and SpringEL helper too.

```
- factoryExpression: "{#actorTypes}" (1)
  actorTypeBased: false
  pathExpression: >
    'lib/' +
    #path(#actorType.name) + '/' +
    'file_for_actor.test' (3)
  templateName: lib/file_for_actor.test.hbs (4)
  templateContext: (5)
    - name: actorTypeAsVariable
      expression: "#self"
```

<1> Factory expression is used to create files. It returns a list of
objects which is used as root context for the given handlebar temlate. (`templateName`)

<2> When actorTypeBased templare used, the template called for all actor types and
the `actorType` variables is defined.

<3> Path expression return with a path where the generated file is placed.

<4> Template is used for generation.

<5> Template context is used to put expression result to template
variable.

```
- overwriteExpression: false
  factoryExpression: "{#model}"
  pathExpression: "'.gitignore'"
  templateName: gitignore
  copy: true (1)

```

<1> For static file without any template `copy` attribute can be used.


== Ignore files on generation

Sometimes a developer needs to replace generated file with custom develped file. On that case
the generation have to ignore the given file to keep the edited version. To achive this
`.generator-ignore` file can be used.  It uses glob format, so the usage is same as '.gitignore'.

