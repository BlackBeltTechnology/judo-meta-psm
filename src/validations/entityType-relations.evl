context Endpoint {
	// endpoint attribute must be a reference
    constraint EndpointAttributeIsNotAReference {
    	check: self.attribute.datatype.isTypeOf(Reference)
    	message: "Invalid attribute type of endpoint " + self.displayName()
    }
    
    // attribute referenced by endpoint must belong to entity type or a supertype of it
    constraint EndpointReferencesToForeignAttribute {
    	check: self.getEntityType().getAllTypes().includes(self.attribute.getEntityType())
    	message: "Foreign attribute referenced by endpoint " + self.displayName() 
    }
}

context Endpoint {
    
    guard: self.partner.isDefined()

    // if partners are specified on both sides of a relation then endpoints must reference to each other
    constraint InvalidPartnerReferences {
    	check: not self.partner.partner.isDefined() or self.partner.partner = self
    	message: "Invalid opposite partner reference for " + self.displayName()
    }
    
    // target and partner types must be aligned
    constraint InvalidPartnerType {
        check: self.partner.getEntityType() = self.attribute.datatype.target and self.partner.attribute.datatype.target = self.getEntityType()
        message: "Invalid partner type: " + self.partner.displayName() + " for " + self.displayName()
    }
    
    // 1-1 single required relationship is not supported
	critique OneToOneRelationNotSupported {
    	guard: self.satisfiesAll("InvalidPartnerReferences", "InvalidPartnerType") and self.partner.satisfiesAll("InvalidPartnerReferences", "InvalidPartnerType")
		check: not(self.attribute.required and not self.attribute.datatype.collection and self.partner.attribute.required and not self.partner.attribute.datatype.collection)
		message: "1-1 relations required on both sides are not supported: " + self.displayName() + " - " + self.partner.displayName()
	}
}

@cached
operation Endpoint displayName() {
	return self.getEntityType().name + "." + self.name;
}

@cached
operation Attribute displayName() {
	return self.getEntityType().name + "." + self.name;
}

@cached
operation Attribute getEntityType() {
	return EntityType.all().select(et | et.attributes.select(a | a = self).size() = 1).first();
}

@cached
operation Endpoint getEntityType() {
    return EntityType.all().select(et | et.endpoints.select(e | e = self).size() = 1).first();
}

@cached
operation EntityType getAllTypes() {
	var types = Set{self};
	if (self.superTypes.isDefined()) {
		for (st : EntityType in self.superTypes) {
			types.add(st);
		}
	}
	return types;
}

@cached
operation Endpoint getOpposites() {
	var opposites = self.attribute.datatype.target.endpoints.select(e | e.attribute.datatype.target = self.getEntityType());
	return opposites;
}
