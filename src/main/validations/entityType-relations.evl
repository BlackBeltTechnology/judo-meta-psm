context JUDOPSM!Structure {

	constraint RecursiveStructureIsNotSupported {
		check: not self.hasCircularReference()
		message: "Element " + self.name + " is a recursive structure that is not supported"
	}
}

context JUDOPSM!Endpoint {
	// endpoint attribute must be a reference
    constraint EndpointAttributeIsNotAReference {
        check: self.datatype.isTypeOf(JUDOPSM!Reference)
    	message: "Invalid attribute type of endpoint " + self.displayName()
    }
}

context JUDOPSM!Endpoint {
    
    guard: self.partner.isDefined()

    // if partners are specified on both sides of a relation then endpoints must reference to each other
    constraint InvalidPartnerReferences {
    	check: not self.partner.partner.isDefined() or self.partner.partner = self
    	message: "Invalid opposite partner reference for " + self.displayName()
    }
    
    // target and partner types must be aligned
    constraint InvalidPartnerType {
        check: self.partner.getEntityType() = self.datatype.target and self.partner.datatype.target = self.getEntityType()
        message: "Invalid partner type: " + self.partner.displayName() + " for " + self.displayName()
    }
    
    // 1-1 single required relationship is not supported
	critique OneToOneRelationNotSupported {
    	guard: self.satisfiesAll("InvalidPartnerReferences", "InvalidPartnerType") and self.partner.satisfiesAll("InvalidPartnerReferences", "InvalidPartnerType")
		check: not(self.required and not self.datatype.collection and self.partner.required and not self.partner.datatype.collection)
		message: "1-1 relations required on both sides are not supported: " + self.displayName() + " - " + self.partner.displayName()
	}
}

context JUDOPSM!Model {
	// model name must be unique
	constraint NameIsNotUnique {
		check: not JUDOPSM!Model.all().select(m | m <> self).collect(m | m.name).includes(self.name)
		message: "Model name is not unique: " + self.name
	}
}

context JUDOPSM!Namespace {
	// data type, entity type and pakcage names must be unique in a package
	constraint NameIsNotUnique {
		check {
			var notUniqueNames = Set{};
			var names = Set{};
			for (p in self.packages) {
				if (names.includes(p.name)) {
					notUniqueNames.add(p.name);
					p.name.println("Name already exists (package): ");
				}
				names.add(p.name);
			}
			for (dt in self.datatypes) {
				if (names.includes(dt.name)) {
					notUniqueNames.add(dt.name);
					dt.name.println("Name already exists (data type): ");
				}
				names.add(dt.name);
			}
			for (et in self.entityTypes) {
				if (names.includes(et.name)) {
					notUniqueNames.add(et.name);
					et.name.println("Name already exists (entity type): ");
				}
				names.add(et.name);
			}
			return notUniqueNames.isEmpty();
		}
		message: "Names " + notUniqueNames + " are not unique in namespace " + self.name
	}
}

@cached
operation JUDOPSM!Attribute displayName() {
	return self.getEntityType().name + "." + self.name;
}

@cached
operation JUDOPSM!Attribute getEntityType() {
	return JUDOPSM!EntityType.all().select(et | et.attributes.select(a | a = self).size() = 1).first();
}

@cached
operation JUDOPSM!EntityType getAllTypes() {
	var types = Set{self};
	if (self.superTypes.isDefined()) {
		for (st in self.superTypes) {
			types.add(st);
		}
	}
	return types;
}

@cached
operation JUDOPSM!Endpoint getOpposites() {
	var opposites = self.datatype.target.endpoints.select(e | e.datatype.target = self.getEntityType());
	return opposites;
}

@cached
operation JUDOPSM!Structure hasCircularReference() {
	var subTypes = Set{};
	for (f in self.fields) {
		if (f.datatype.isTypeOf(JUDOPSM!Structure)) {
			subTypes.add(f.datatype);
		}
	}
	return self.hasCircularReference(subTypes);
}

operation JUDOPSM!Structure hasCircularReference(visited : Set) {
    if (visited.includes(self)) {
        return true;
    } else if (visited.isEmpty()) {
        return false;
    }

    var subTypes = Set{};
    for (s in visited) {
		for (f in s.fields) {
			if (f.datatype.isTypeOf(JUDOPSM!Structure)) {
				subTypes.add(f.datatype);
			}
		}
    }

    return self.hasCircularReference(subTypes);
}
