@cached
operation EXPR!ElementName getNamespace() : JUDOPSM!NamedElement {
    var ns : JUDOPSM!Namespace;
    
    for (nsName in self.namespace.split("\\s*\\::\\s*")) {
        if (ns.isDefined()) {
            ns = ns.packages.selectOne(p | p.name = nsName);
        } else {
            ns = JUDOPSM!Model.all.selectOne(p | p.name = nsName);
            if (not ns.isDefined()) {
                nsName.println("Model not found: ");
                return null;
            }
        }
    }
    
    return ns;
}

@cached
operation EXPR!ElementName get() : JUDOPSM!NamedElement {
    return self.getNamespace().elements.selectOne(ne | ne.name = self.name);
}

@cached
operation EXPR!ElementName getObjectType() : JUDOPSM!Type {
    return self.getNamespace().elements.selectOne(et | et.name = self.name);
}

@cached
operation EXPR!ElementName getEnumerationType() : JUDOPSM!EntityType {
    return self.getNamespace().elements.selectOne(t | t.name = self.name);
}

@cached
operation EXPR!ElementName getMeasure() : JUDOPSM!Measure {
    return self.getNamespace().elements.selectOne(m | m.name = self.name);
}

operation JUDOPSM!EntityType getReferenceType(name: String) : JUDOPSM!ReferenceTypedElement {
    var relation = self.relations.selectOne(r | r.name = name);
    var navigation = JUDOPSM!NavigationProperty.all.selectOne(n | n.name = name and n.owner = self);
    
    if (relation.isDefined()) {
        return relation;
    } else if (navigation.isDefined()) {
        return navigation;
    } else {
        // checking super types recursively
        var super = self.superEntityTypes;
        while (super.isDefined() and not super.isEmpty()) {
            var super2 = new Sequence;
            for (s in super) {
                relation = s.relations.selectOne(r | r.name = name);
                navigation = JUDOPSM!NavigationProperty.all.selectOne(n | n.name = name and n.owner = s);
                
                if (relation.isDefined()) {
                    return relation;
                } else if (navigation.isDefined()) {
                    return navigation;
                }
                
                super2.addAll(s.superEntityTypes);
            }
            super = super2;
        }
    }
    
    return null;
}

@cached
operation JUDOPSM!ReferenceTypedElement isCollection() : Boolean {
    return self.cardinality.upper > 1 or self.cardinality.upper == -1;
}

@cached
operation JUDOPSM!ReferenceTypedElement getTarget() : JUDOPSM!EntityType {
    return self.target;
}

operation JUDOPSM!EntityType getAttributeType(name: String) : JUDOPSM!Primitive {
    var attr = self.attributes.selectOne(r | r.name = name);
    var prop = JUDOPSM!DataProperty.all.selectOne(p | p.name = name and p.owner = self);
    
    if (attr.isDefined()) {
        return attr.dataType;
    } else if (prop.isDefined()) {
        return prop.dataType;
    } else {
        // checking super types recursively
        var super = self.superEntityTypes;
        while (super.isDefined() and not super.isEmpty()) {
            var super2 = new Sequence;
            for (s in super) {
                attr = s.attributes.selectOne(a | a.name = name);
                prop = JUDOPSM!DataProperty.all.selectOne(p | p.name = name and p.owner = s);
                
                if (attr.isDefined()) {
                    return attr.dataType;
                } else if (prop.isDefined()) {
                    return prop.dataType;
                }
                
                super2.addAll(s.superEntityTypes);
            }
            super = super2;
        }
    }
    
    return null;
}

@cached
operation JUDOPSM!EntityType getSuperTypes() : Sequence {
    var result = new Sequence;
    
    var super = self.superEntityTypes;
    while (super.isDefined() and not super.isEmpty()) {
        result.addAll(super);
        
        var super2 = new Sequence;
        for (s in super) {
            super2.addAll(s.superEntityTypes);
        }
        super = super2;
    }
    
    return result;
}

@cached
operation JUDOPSM!Primitive isNumeric() : Boolean {
    return self.isKindOf(JUDOPSM!NumericType);
}

@cached
operation JUDOPSM!Primitive isInteger() : Boolean {
    return self.isNumeric() and self.precision == 0;
}

@cached
operation JUDOPSM!Primitive isDecimal() : Boolean {
    return self.isNumeric() and self.precision > 0;
}

@cached
operation JUDOPSM!Primitive isMeasured() : Boolean {
    return self.isKindOf(JUDOPSM!MeasuredType);
}

@cached
operation JUDOPSM!Primitive isBoolean() : Boolean {
    return self.isKindOf(JUDOPSM!BooleanType);
}

@cached
operation JUDOPSM!Primitive isString() : Boolean {
    return self.isKindOf(JUDOPSM!StringType);
}

@cached
operation JUDOPSM!Primitive isEnumeration() : Boolean {
    return self.isKindOf(JUDOPSM!EnumerationType);
}

@cached
operation JUDOPSM!Primitive isCustom() : Boolean {
    return not self.isNumeric() and not self.isBoolean() and not self.isString() and not self.isEnumeration();
}

operation JUDOPSM!EnumerationType contains(memberName : String) : Boolean {
    return self.members.selectOne(m | m.name = memberName).isDefined();
}

@cached
operation JUDOPSM!NamedElement getName() : String {
    return self.name;
}

operation JUDOPSM!Measure getUnit(name : String) : JUDOPSM!Unit {
    return self.units.selectOne(u | u.name = name or u.symbol = name);
}

@cached
operation JUDOPSM!MeasuredType getUnit() : JUDOPSM!Unit {
    return self.storeUnit;
}

@cached
operation JUDOPSM!Unit toString() : String {
    if (self.symbol.isDefined()) {
        return self.symbol;
    } else {
        return self.name;
    }
}

@cached
operation JUDOPSM!Unit getMeasure() : JUDOPSM!Measure {
    return JUDOPSM!Measure.all.selectOne(m | m.units.contains(self));
}

@cached
operation getDimensions() : Map {
    var dimensions = new Map;
    for (m in JUDOPSM!Measure.all) {
        dimensions.put(m.getBaseMeasures(), m);
    }
    return dimensions;
}

@cached
operation JUDOPSM!Measure getBaseMeasures() : Map {
    if (self.isKindOf(JUDOPSM!DerivedMeasure)) {
        var baseMeasures = new Map;
        for (t in self.terms) {
            var termBases = t.unit.getMeasure().getBaseMeasures();
            for (m in termBases.keySet()) {
                var exponent = termBases.get(m) * t.exponent;

                var currentExponent = baseMeasures.get(m);
                if (currentExponent.isDefined()) {
                    var newExponent = currentExponent + exponent;
                    if (newExponent <> 0) {
                        baseMeasures.put(m, newExponent);
                    } else {
                        baseMeasures.remove(m);
                    }
                } else {
                    baseMeasures.put(m, exponent);
                }
            }
        }
        return baseMeasures;
    } else {
        return Map{self = 1};
    }
}

@cached
operation EXPR!NumericAttribute getMeasure() : JUDOPSM!Measure {
    if (self.isMeasured()) {
        return JUDOPSM!Measure.all.selectOne(m | m.units.contains(self.getUnit()));
    } else {
        return Map{};
    }
}

@cached
operation EXPR!MeasuredDecimal getUnit() {
    if (self.measure.isDefined()) {
        return self.measure.getMeasure().units.selectOne(u | u.name = self.unitName or u.symbol = self.unitName);
    } else {
        var units = JUDOPSM!Unit.all.select(u | u.name = self.unitName or u.symbol = self.unitName);
        if (units.size() == 1) {
            return units.get(0);
        } else {
            units.collect(u | u.getMeasure().name + ": " + u.name + " [" + u.symbol + "]").concat(", ").println("Multiple units found with name " + self.unitName + ": ");
            return null;
        }
    }
}

@cached
operation EXPR!MeasuredInteger getUnit() {
    if (self.measure.isDefined()) {
        return self.measure.getMeasure().units.selectOne(u | u.name = self.unitName or u.symbol = self.unitName);
    } else {
        var units = JUDOPSM!Unit.all.select(u | u.name = self.unitName or u.symbol = self.unitName);
        if (units.size() == 1) {
            return units.get(0);
        } else {
            units.collect(u | u.getMeasure().name + ": " + u.name + " [" + u.symbol + "]").concat(", ").println("Multiple units found with name " + self.unitName + ": ");
            return null;
        }
    }
}
