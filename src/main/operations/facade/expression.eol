import "property.eol";

@cached
operation parseExpression(expression : String) {
    var parser = new Native("hu.blackbelt.judo.model.scripting.StringExpressionParser");
    
    return parser.parseExpression(expression);
}

@cached
operation JUDOPSM!Property validatePath() : Sequence {
	var expression = parseExpression(self.path);
	
	var errors = new Sequence;
	
	if (expression.class.name <> "hu.blackbelt.judo.model.scripting.model.SelfEntityFormula") {
		errors.add("PathIsNotASelfExpression|Navagation path is not a SELF expression");
	} else {
		var entityType = self.getFacade().entityType;
		
		var expressionDataType;
		
		for (r in expression.relationList) {
			var attribute = entityType.attributes.selectOne(a | a.name = r.identifier);
			var reference = entityType.references.selectOne(e | e.name = r.identifier);
			
			if (attribute.isDefined()) {
				entityType = null;
				expressionDataType = attribute.primitive;
			} else if (reference.isDefined()) {
				entityType = reference.target;
				if (reference.isCollection()) {
					errors.add("AggregatedPathsAreNotSupportedYet|Path expression contains aggregation that is not supported yet");
					break;
				}
			} else {
				errors.add("InvalidPropertyPath|Attribute of entity " + entityType.name + " not found: " + r.identifier);
				break;
			}
		}
		
		if (expressionDataType.isDefined() and expressionDataType <> self.type) {
			errors.add("InvalidPathDataType|Invalid data type, expected: " + expressionDataType.name + ", found in model: " + self.type.name + "; property: " + self.displayName() + "; path: " + self.path);
		}
	}
	
	if (not errors.isEmpty()) {
		errors.println("Invalid navigation path: ");
	}
	
	return errors;
}
