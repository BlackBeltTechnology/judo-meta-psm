@namespace(uri="http://blackbelt.hu/judo/meta/psm", prefix="psm")
package psm;

class PlaceHolder {
}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/namespace", prefix="namespace")
package namespace {
  abstract class NamedElement {
    attr String[1] name;
  }

  abstract class Namespace extends NamedElement {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.namespaceToString(this);")
    op String[1] toString();
    val NamespaceElement[*] elements;
    val Package[*] packages;
  }

  class Model extends Namespace {
  }

  class Package extends Namespace {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getNamespaceOfPackage(this).get();")
    op Namespace[1] getNamespace();
  }

  abstract class NamespaceElement extends NamedElement {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.namespaceElementToString(this);")
    op String[1] toString();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getNamespaceOfNamespaceElement(this).get();")
    op Namespace[1] getNamespace();
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/type", prefix="type")
package type {
  abstract class Primitive extends DataType {

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.type.NumericType;")
    op boolean[1] isNumeric();

    @GenModel(body="return isNumeric() && ((hu.blackbelt.judo.meta.psm.type.NumericType)this).getScale() == 0;")
    op boolean[1] isInteger();

    @GenModel(body="return isNumeric() && ((hu.blackbelt.judo.meta.psm.type.NumericType)this).getScale() > 0;")
    op boolean[1] isDecimal();

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.type.StringType;")
    op boolean[1] isString();

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.type.BooleanType;")
    op boolean[1] isBoolean();

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.type.DateType;")
    op boolean[1] isDate();

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.type.TimestampType;")
    op boolean[1] isTimestamp();

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.type.EnumerationType;")
    op boolean[1] isEnumeration();

    @GenModel(body="return this instanceof hu.blackbelt.judo.meta.psm.measure.MeasuredType;")
    op boolean[1] isMeasured();
  }

  class CustomType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
  }

  class StringType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
    attr int[1] maxLength;
    attr RegExp regExp;
  }

  class NumericType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
    attr int[1] precision;
    attr int[1] scale;
  }

  class BooleanType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
  }

  class EnumerationType extends Primitive {

    @GenModel(body="return getMembers().stream().filter(m -> java.util.Objects.equals(name, m.getName())).count() > 0;")
    op boolean[1] contains(!ordered String[1] name);

    @GenModel(body="return super.toString();")
    op String[1] toString();
    val EnumerationMember[+] members;
  }

  class EnumerationMember extends namespace.NamedElement {
    attr int[1] ordinal;
  }

  abstract class Type extends namespace.NamespaceElement {
  }

  abstract class DataType extends Type {
  }

  class XMLType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
    attr XmlNamespace[1] xmlNamespace;
    attr XmlElement[1] xmlElement;
  }

  class Cardinality {
    attr int[1] lower = 0;
    attr int[1] upper = 1;
  }

  datatype RegExp : java.lang.String;

  class PasswordType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
  }

  datatype XmlNamespace : java.lang.String;

  datatype XmlElement : java.lang.String;

  class DateType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
  }

  class TimestampType extends FlatPrimitiveType {

    @GenModel(body="return super.toString();")
    op String[1] toString();
    attr measure.DurationType[1] baseUnit = "second";
  }

  abstract class FlatPrimitiveType extends Primitive {
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/data", prefix="data")
package data {
  class EntityType extends type.Type {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getAllSuperEntityTypes(this);")
    !ordered op EntityType[*] getAllSuperEntityTypes();

    @GenModel(body="        final java.util.Collection<EntityType> base = new java.util.ArrayList<>(getAllSuperEntityTypes());
        base.add(this);

        final java.util.Optional<java.util.Optional<Attribute>> attribute = base.stream()
                .filter(e -> e.getAttributes().stream().anyMatch(a -> java.util.Objects.equals(name, a.getName()))) // get all types containing attribute named name
                .map(e -> e.getAttributes().stream().filter(a -> java.util.Objects.equals(name, a.getName())).findFirst()) // get attributes of types
                .findFirst(); // redefining attributes is not supported
        final java.util.Optional<java.util.Optional<DataProperty>> dataProperty = base.stream()
                .filter(e -> e.getDataProperties().stream().anyMatch(d -> java.util.Objects.equals(name, d.getName()))) // get all types containing data property named name
                .map(e -> e.getDataProperties().stream().filter(d -> java.util.Objects.equals(name, d.getName())).findFirst()) // get data properties of types
                .findFirst(); // redefining data properties is not supported

        if (attribute.isPresent()) {
            return attribute.get().get();
        } else if (dataProperty.isPresent()) {
            return dataProperty.get().get();
        } else {
            return null;
        }")
    op PrimitiveTypedElement getAttribute(!ordered String[1] name);

    @GenModel(body="        final java.util.Collection<EntityType> base = new java.util.ArrayList<>(getAllSuperEntityTypes());
        base.add(this);

        final java.util.Optional<java.util.Optional<Relation>> relation = base.stream()
                .filter(e -> e.getRelations().stream().anyMatch(r -> java.util.Objects.equals(name, r.getName()))) // get all types containing reference named name
                .map(e -> e.getRelations().stream().filter(r -> java.util.Objects.equals(name, r.getName())).findFirst()) // get references of types
                .findFirst(); // redefining references is not supported
        final java.util.Optional<java.util.Optional<NavigationProperty>> navigationProperty = base.stream()
                .filter(e -> e.getNavigationProperties().stream().anyMatch(n -> java.util.Objects.equals(name, n.getName()))) // get all types containing navigation property named name
                .map(e -> e.getNavigationProperties().stream().filter(n -> java.util.Objects.equals(name, n.getName())).findFirst()) // get navigation properties of types
                .findFirst(); // redefining navigation properties is not supported

        if (relation.isPresent()) {
            return relation.get().get();
        } else if (navigationProperty.isPresent()) {
            return navigationProperty.get().get();
        } else {
            return null;
        }")
    op ReferenceTypedElement getReference(!ordered String[1] name);

    @GenModel(body="        final PrimitiveTypedElement attribute = getAttribute(name);

        if (attribute != null) {
            return attribute.getDataType();
        } else {
            return null;
        }")
    op type.Primitive getAttributeType(!ordered String[1] name);

    @GenModel(body="return super.toString();")
    op String[1] toString();

    @GenModel(body="return getRelations().stream().anyMatch(r -> r instanceof hu.blackbelt.judo.meta.psm.data.Containment);")
    op boolean[1] isContainer();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.isContainment(this);")
    op boolean[1] isContainment();
    !ordered op Relation[*] getAllRelations();
    !ordered op Attribute[*] getAllAttributes();
    !ordered op ~derived.DataProperty[*] getAllDataProperties();
    !ordered op ~derived.NavigationProperty[*] getAllNavigationProperties();
    ref EntityType[*] superEntityTypes;
    attr boolean[1] ~abstract;
    val Attribute[*] attributes;
    val Relation[*] relations;
    val ~derived.DataProperty[*] dataProperties;
    val ~derived.NavigationProperty[*] navigationProperties;
    val EntitySequence[*] sequences;
  }

  abstract class Relation extends ReferenceTypedElement, EntityMember {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.relationToString(this);")
    op String[1] toString();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getEntityTypeOfRelation(this).get();")
    op EntityType[1] getEntityType();
  }

  class Attribute extends PrimitiveTypedElement, EntityMember {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.attributeToString(this);")
    op String[1] toString();

    @GenModel(body="return getDataType() instanceof hu.blackbelt.judo.meta.psm.type.Primitive;")
    op boolean[1] isPrimitive();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getEntityTypeOfAttribute(this).get();")
    op EntityType[1] getEntityType();
    attr boolean[1] identifier;
  }

  class AssociationEnd extends Relation {

    @GenModel(body="return getTarget() != null ? getTarget().getRelations().stream().filter(r -> org.eclipse.emf.ecore.util.EcoreUtil.equals(r.getTarget(), this)).findAny().orElse(null) : null;")
    op Relation getOpposite();
    ref AssociationEnd partner;
    attr boolean[1] reverseCascadeDelete = false;
  }

  abstract class ReferenceTypedElement extends namespace.NamedElement {

    @GenModel(body="if (getCardinality() == null) {
    return false;
} else {
    return getCardinality().getUpper() == -1 || getCardinality().getUpper() > 1;
}")
    op boolean[1] isCollection();

    @GenModel(body="return getCardinality() != null && getCardinality().getLower() > 0;")
    op boolean[1] isRequired();
    op EntityType[1] getEntityType();
    ref EntityType[1] target;
    val type.Cardinality[1] cardinality;
  }

  abstract class PrimitiveTypedElement extends namespace.NamedElement {
    op EntityType[1] getEntityType();
    ref type.Primitive[1] dataType;
    attr boolean[1] required;
  }

  class Containment extends Relation {
  }

  abstract interface EntityMember {
  }

  abstract class Sequence {
    attr long[1] initialValue = "0";
    attr long[1] increment = "1";
    attr long maximumValue;
    attr boolean[1] cyclic = false;
  }

  class EntitySequence extends EntityMember, Sequence, namespace.NamedElement {
  }

  class NamespaceSequence extends Sequence, namespace.NamespaceElement {
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/constraint", prefix="constraint")
package constraint {
  class InvariantConstraint extends namespace.NamedElement {
    val ~derived.LogicalExpressionType[1] expression;
    ref data.EntityType[1] constrained;
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/script", prefix="script")
package script {
  datatype Script : java.lang.String;

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/derived", prefix="derived")
package ~derived {
  class DataProperty extends PrimitiveAccessor {

    @GenModel(body="return getDataType() instanceof hu.blackbelt.judo.meta.psm.type.Primitive;")
    op boolean[1] isPrimitive();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getEntityTypeOfDataProperty(this).get();")
    op data.EntityType[1] getEntityType();
  }

  class NavigationProperty extends ReferenceAccessor {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getEntityTypeOfNavigationProperty(this).get();")
    op data.EntityType[1] getEntityType();
  }

  class StaticNavigation extends ReferenceAccessor, namespace.NamespaceElement {
  }

  abstract class PrimitiveAccessor extends data.PrimitiveTypedElement {
    val DataExpressionType[1] getterExpression;
    val AttributeSelectorType setterExpression;
  }

  class StaticData extends PrimitiveAccessor, namespace.NamespaceElement {
  }

  abstract class ReferenceAccessor extends data.ReferenceTypedElement {
    val ReferenceExpressionType[1] getterExpression;
    val ReferenceSelectorType setterExpression;
  }

  abstract class ExpressionType {
    attr String[1] expression;
    attr ExpressionDialect[1] dialect;
  }

  enum ExpressionDialect {
    JQL = 0;
    XML = 1;
  }

  class ReferenceExpressionType extends ExpressionType {
  }

  class ReferenceSelectorType extends ReferenceExpressionType {
  }

  class DataExpressionType extends ExpressionType {
  }

  class AttributeSelectorType extends DataExpressionType {
  }

  class LogicalExpressionType extends DataExpressionType {
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/service", prefix="service")
package service {
  abstract class TransferObjectType extends type.DataType {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getAllSuperTransferObjectTypes(this);")
    !ordered op TransferObjectType[*] getAllSuperTransferObjectTypes();
    !ordered op String[*] getInheritedTransferAttributeNames();
    !ordered op String[*] getInheritedTransferObjectRelationNames();
    ref TransferAttribute representation;
    val TransferObjectRelation[*] relations;
    val TransferAttribute[*] attributes;
    ref TransferObjectType[*] superTransferObjectTypes;
  }

  class TransferObjectRelation extends namespace.NamedElement {

    @GenModel(body="if (getCardinality() == null) {
    return false;
} else {
    return getCardinality().getUpper() == -1 || getCardinality().getUpper() > 1;
}")
    op boolean[1] isCollection();

    @GenModel(body="return getCardinality() != null && getCardinality().getLower() > 0;")
    op boolean[1] isRequired();

    @GenModel(body="return (getBinding() instanceof hu.blackbelt.judo.meta.psm.data.Relation) ||
                (getBinding() instanceof hu.blackbelt.judo.meta.psm.derived.ReferenceAccessor) && ((hu.blackbelt.judo.meta.psm.derived.ReferenceAccessor)getBinding()).getSetterExpression() != null;")
    op boolean[1] isMutable();

    @GenModel(body="return (eContainer() instanceof hu.blackbelt.judo.meta.psm.service.MappedTransferObjectType);")
    op boolean[1] isNavigable();
    val type.Cardinality[1] cardinality;
    ref data.ReferenceTypedElement binding;
    ref ~derived.StaticNavigation defaultValue;
    ref ~derived.ReferenceAccessor range;
    ref TransferObjectType[1] target;
    attr boolean[1] embedded = false;
    ref BoundOperation create;
    attr boolean[1] creatableElement;
    attr boolean[1] updatableElement;
    ref BoundOperation update;
    ref BoundOperation delete;
    ref BoundOperation set;
    ref BoundOperation get;
    ref BoundOperation unset;
    ref BoundOperation addAll;
    ref BoundOperation removeAll;
    ref UnboundOperation getRange;
  }

  class TransferAttribute extends namespace.NamedElement {

    @GenModel(body="return getDataType() instanceof hu.blackbelt.judo.meta.psm.type.Primitive;")
    op boolean[1] isPrimitive();
    attr boolean[1] required;
    ref ~derived.StaticData defaultValue;
    ref type.Primitive[1] dataType;
    ref data.PrimitiveTypedElement binding;
  }

  class MappedTransferObjectType extends TransferObjectType {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.isAbstractMappedTransferObjectType(this);")
    op boolean[1] isAbstract();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.isInstantiableMappedTransferObjectType(this);")
    op boolean[1] isInstantiable();
    op String[*] getAllOperationNames();
    !unique op OperationBody[*] getInheritedOperationImplementationsByName(String name);
    !unique op OperationBody[1] getInheritedOperationImplementationByName(String name);
    op String[*] getInheritedOperationNames();
    ref data.EntityType[1] entityType;
    val BoundOperation[*] operations;
    val ~derived.LogicalExpressionType filter;
    ref UnboundOperation getTemplate;
  }

  abstract class OperationDeclaration {
    val Parameter[*] faults;
    val Parameter output;
    val Parameter input;
  }

  class UnmappedTransferObjectType extends TransferObjectType {
  }

  class BoundOperation extends namespace.NamedElement, OperationDeclaration {
    val OperationBody implementation;
  }

  class UnboundOperation extends namespace.NamespaceElement, OperationDeclaration {
    val OperationBody[1] implementation;
  }

  class Parameter extends namespace.NamedElement {
    val type.Cardinality[1] cardinality;
    ref TransferObjectType[1] type;
  }

  class OperationBody {
    attr boolean[1] stateful;
    attr boolean[1] customImplementation;
    attr script.Script body;
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/accesspoint", prefix="accesspoint")
package accesspoint {
  class AccessPoint extends namespace.NamespaceElement {
    val ExposedGraph[*] exposedGraphs;
    val ExposedService[*] exposedServices;
  }

  class ExposedGraph extends namespace.NamedElement {
    ref service.MappedTransferObjectType[1] mappedTransferObjectType;
    ref ~derived.StaticNavigation[1] selector;
    val type.Cardinality[1] cardinality;
    ref service.UnboundOperation get;
    ref service.UnboundOperation create;
    ref service.BoundOperation update;
    ref service.BoundOperation delete;
  }

  class ExposedService {
    ref service.UnboundOperation[1] operation;
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/view", prefix="view")
package view {
  class Container extends namespace.NamedElement {
    val Component[*] components;
    attr LayoutType[1] layout;
    attr String title;
    attr AlignmentType[1] alignment;
  }

  abstract class Component extends namespace.NamedElement {
    attr String label;
    transient derived ref ObjectView[1] parentView;
  }

  class Widget extends Component {
    ref service.TransferAttribute[1] transferAttribute;
    val Event[*] emittedEvents;
  }

  class ObjectView extends Container, namespace.NamespaceElement {
    ref service.TransferObjectType[1] transferObject;
    attr ViewType[1] viewType;
    val Control[*] controls;
  }

  class Groupbox extends Container, Component {
  }

  class Placeholder extends Component {
    attr boolean[1] popup;
  }

  abstract class Navigation extends Component {
    ref ObjectView[1] navigationView;
    ref ObjectView rangeView;
    ref service.TransferObjectRelation[1] transferRelation;
  }

  class Link extends Navigation {
    ref Placeholder target;
    attr String text;
  }

  class Embedded extends Navigation {
  }

  class Action extends Component {
    ref Placeholder target;
    ref service.OperationDeclaration[1] operation;
    ref ObjectView resultView;
    ref ObjectView[*] faultViews;
  }

  abstract class Control {
    ref service.TransferAttribute[1] controller;
    ref Component[*] components;
  }

  class VisibleControl extends Control {
  }

  class EnabledControl extends Control {
  }

  enum EventType {
    SYSTEM_CHANGED = 0;
    USER_CHANGED = 1;
    ENABLED = 2;
    DISABLED = 3;
    SHOWN = 4;
    HIDE = 5;
    LOADED = 6;
  }

  enum ViewType {
    LIST = 0;
    GRID = 1;
    TILE = 2;
  }

  enum LayoutType {
    HORIZONTAL = 0;
    VERTICAL = 1;
    TAB = 2;
  }

  abstract class ViewControl extends Component {
  }

  class Event {
    attr EventType[1] eventType;
    ref Action[1] triggered;
  }

  abstract class MenuComponent extends Component {
    val Menu[*] subMenus;
    val MenuItem[*] menuItems;
  }

  class MenuBar extends MenuComponent {
  }

  class Menu extends MenuComponent {
  }

  abstract class MenuItem {
    ref ObjectView[1] view;
    ref Placeholder[1] target;
  }

  class EntryMenuItem extends MenuItem {
    ref ~derived.StaticNavigation[1] selector;
  }

  class ActionMenuItem extends MenuItem {
    ref service.OperationDeclaration[1] exposedService;
  }

  class UserInterface extends namespace.NamespaceElement {
    ref ObjectView[1] mainView;
    val ~derived.StaticNavigation selector;
  }

  class Renderer {
  }

  class Back extends ViewControl {
  }

  class UnboundActionLink extends Component {
    ref ObjectView[1] actionView;
  }

  enum AlignmentType {
    TOP = 0;
    BOTTOM = 1;
    LEFT = 2;
    RIGHT = 3;
    CENTER = 4;
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/authentication", prefix="authentication")
package authentication {
  class PasswordAuthenticatedUser extends AuthenticatedUser {
    ref data.Attribute[1] password;
    ref data.Attribute[1] login;
  }

  abstract class AuthenticatedUser {
    ref data.EntityType[1] user;
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/authorization", prefix="authorization")
package authorization {
  class AuthorizationResource extends namespace.NamespaceElement {
    ref data.ReferenceTypedElement[*] referenceTypedElements;
    ref service.OperationDeclaration[*] operations;
    ref AuthorizationResource[*] includedAuthorizationResources;
  }

}

@namespace(uri="http://blackbelt.hu/judo/meta/psm/measure", prefix="measure")
package measure {
  class Measure extends namespace.NamespaceElement {
    val Unit[*] units;
    attr String symbol;
  }

  class MeasuredType extends type.NumericType {
    ref Unit[1] storeUnit;
  }

  class Unit extends namespace.NamedElement {

    @GenModel(body="return getSymbol() != null ? getSymbol() : getName();")
    op String[1] toString();

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getMeasure(this).get();")
    op Measure[1] getMeasure();
    attr double[1] rateDividend = "1";
    attr double[1] rateDivisor = "1";
    attr String symbol;
  }

  class MeasureDefinitionTerm {
    attr int[1] exponent = 1;
    ref Unit[1] unit;
  }

  enum DurationType {
    nanosecond = 8;
    microsecond = 9;
    millisecond = 0;
    second = 1;
    minute = 2;
    hour = 3;
    day = 4;
    week = 5;
    month = 6;
    year = 7;
  }

  class DurationUnit extends Unit {
    attr DurationType[1] unitType;
  }

  class DerivedMeasure extends Measure {

    @GenModel(body="return hu.blackbelt.judo.meta.psm.PsmUtils.getAllTermMeasures(this);")
    op Measure[+] getAllTermMeasures();
    val MeasureDefinitionTerm[+] terms;
  }

}

