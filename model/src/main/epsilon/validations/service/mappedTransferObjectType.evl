context PSM!MappedTransferObjectType{
  
    /*constraint NeedToOverrideMultipleOperationImplementations {
        guard: self.getAllSuperTransferObjectTypes().select(t | t.isKindOf(PSM!MappedTransferObjectType))
            .forAll(s | s.satisfies("NeedToOverrideMultipleOperationImplementations"))
        check: self.getAllOperationNames().forAll(opName | self.getInheritedOperationImplementationsByName(opName).size() > 1 implies 
                        self.operations.exists(o | o.name.toLowerCase() == opName.toLowerCase() and o.implementation.isDefined()))
        message: "Mapped transfer object type: " + self.name + " has inherited operations without implementation, "
                + "but their bases have more than one implementation."
    } */
    
    constraint EntityTypeMatchesEntityTypeOfBaseMappedTransferObject {
        check: self.getAllSuperTransferObjectTypes().select(t | t.isKindOf(PSM!MappedTransferObjectType))
                            .forAll(sto | self.entityType.getAllSuperEntityTypes().including(self.entityType).contains(sto.entityType))
        message: "Entity type of mapped transfer object type: " + self.name + " must derive from the entity types of the base mapped transfer object type of mapped transfer object type: " + self.name
    }
    
    /*In cases of multiple inheritance, the constraint checks, whether each inherited operation can be traced back to exactly one mapped transfer object type where it was first declared.
    The rule collects all operations of all super mapped transfer object types, then checks whether all operations (op) fulfill the following: there is exactly one super transfer object type (of self),
    which (1) contains an operation with the same name and (2) has no super transfer object type containing an operation with the same name.*/
    /*constraint BoundOperationInheritanceIsValid {
        check: self.getAllSuperTransferObjectTypes()
                    .select(s | s.isKindOf(PSM!MappedTransferObjectType))
                    .collect(s | s.getOperations().collect(n | n.name.toLowerCase()))
                    .flatten()
                    .forAll(op | self.getAllSuperTransferObjectTypes()
                                    .select(s | s.isKindOf(PSM!MappedTransferObjectType))
                                    .select(t | t.getOperations()
                                              .exists(o | o.name.toLowerCase() == op) and
                                                          not t.getAllSuperTransferObjectTypes()
                                                              .select(s | s.isKindOf(PSM!MappedTransferObjectType))
                                                              .exists(t2 | t2.getOperations().exists(o | o.name.toLowerCase() == op)))
                                 .size() == 1)
        message: "Mapped transfer object type: " + self.name + " is inheriting operation(s) having the same name from unrelated mapped transfer object."
    } */

    /*constraint InheritedOperationAndTransferAttributeNamesAreUnique {
        check: not self.getInheritedTransferAttributeNames().exists(name | self.getInheritedOperationNames().exists(a | name.toLowerCase() == a.toLowerCase()))
        message: "Mapped transfer object type: " + self.name + " has inherited operation(s) and inherited transfer attribute(s) of the same name." 
    }

    constraint InheritedOperationAndTransferObjectRelationNamesAreUnique {
        check: not self.getInheritedTransferObjectRelationNames().exists(name | self.getInheritedOperationNames().exists(a | name.toLowerCase() == a.toLowerCase()))
        message:  "Mapped transfer object type: " + self.name + " has inherited operation(s) and inherited transfer object relation(s) of the same name."
    }*/
}
