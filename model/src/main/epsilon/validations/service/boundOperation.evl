context PSM!BoundOperation {
    
    //Check overriding when inherited operation input is defined
    constraint OverridingWithValidInput {
        guard: self.satisfies("NamedElementHasContainer") and self.input.isDefined()
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | o.input.isDefined() and o.input.type == self.input.type)
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change input type."
    }

    //Check overriding when inherited operation has no input   
    constraint OverridingWithValidInput {
        guard: self.satisfies("NamedElementHasContainer") and (not self.input.isDefined())
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | not o.input.isDefined())
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change input type."
    }
    
    //Check overriding when inherited operation output is defined
    constraint OverridingWithValidOutput {
        guard: self.satisfies("NamedElementHasContainer") and self.output.isDefined()
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | o.output.isDefined() and o.output.type == self.output.type)
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change output type."
    }
    
    //Check overriding when inherited operation output is void
    constraint OverridingWithValidOutput {
        guard: self.satisfies("NamedElementHasContainer") and (not self.output.isDefined())
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | not o.output.isDefined())
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change output type."
    }
    
    //Check overriding when inherited operation has no faults
    constraint OverridingWithValidFaults {
        guard: self.satisfies("NamedElementHasContainer") and self.faults.size() == 0
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | o.faults.size() == 0)
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change the type of faults."
     }
     
     //Check overriding when inherited operation has one or more faults
     constraint OverridingWithValidFaults {
        guard: self.satisfies("NamedElementHasContainer") and self.faults.size() > 0
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | self.faults.size() == o.faults.size() and 
                            o.faults.collect(f | f.type.name).sortBy(n | n).equals(self.faults.collect(f | f.type.name).sortBy(n | n)) )
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change the type of faults."
     }
     
     //If inherited overriden operation has no implementation, neither of its base operations can have implementation
     constraint InheritedBoundOperationHasNoImplementation {
        guard: self.satisfies("NamedElementHasContainer")
        check: (not self.implementation.isDefined()) implies
               self.eContainer().getInheritedOperationImplementationsByName(self.name).size() == 0
        message: "Bases of bound operation: " + self.name + " cannot have implementation, if " + self.name + " in mapped transfer object type: "
                    + self.eContainer().name + " doesn't have one."
    }
}