context PSM!TransferOperationBehaviour {
	
	guard: self.eContainer.isDefined() and 
		(self.behaviourType == PSM!TransferOperationBehaviourType#GET or
		self.behaviourType == PSM!TransferOperationBehaviourType#CREATE or
		self.behaviourType == PSM!TransferOperationBehaviourType#UPDATE or
		self.behaviourType == PSM!TransferOperationBehaviourType#DELETE)
		and self.satisfiesAll("OperationIsValidUnboundBehaviour","OwnerIsRelationUnboundBehaviour")
	
	constraint RelationIsUndefinedUnboundWithoutRelation {
		check: self.relation.isUndefined()
		message: "Relation must be undefined for '" + self.behaviourType + "' operation: " + self.eContainer.name  + " (in: " + self.eContainer.eContainer.name + ")"
	}
}

context PSM!TransferOperationBehaviour {
	
	guard: self.eContainer.isDefined()
		and self.behaviourType == PSM!TransferOperationBehaviourType#GET
		and self.satisfiesAll("OperationIsValidUnboundBehaviour","OwnerIsRelationUnboundBehaviour","RelationIsUndefinedUnboundWithoutRelation")

    constraint GetOperationOutputParameterIsDefined {
    	check: self.eContainer.output.isDefined()
    	message: "'GET' operation must have an output parameter named 'output' (operation: " + self.eContainer.name + ")"
    }
    
    constraint GetOperationInputNameIsValid {
        guard: self.eContainer.input.isDefined()
        check: self.eContainer.input.name == "input"
        message: "'GET' operation's input parameter must be named 'input' (operation: " + self.eContainer.name + ")"
    }

    constraint GetOperationOutputNameIsValid {
    	guard: self.satisfies("GetOperationOutputParameterIsDefined")
    	check: self.eContainer.output.name == "output"
    	message: "'GET' operation's output parameter must be named 'output' (operation: " + self.eContainer.name + ")"
    }
    
    constraint GetOperationOutputTypeIsValid {
    	guard: self.satisfies("GetOperationOutputParameterIsDefined")
    	check: self.eContainer.output.type.equals(self.owner.target)
    	message: "Type of 'GET' operation's output parameter must be type of exposed graph's mapped transfer object type (operation: " + self.eContainer.name + ")"
    }
    
    constraint GetOperationInputCardinalityIsValid {
        guard: self.eContainer.input.isDefined()
        check: self.eContainer.input.cardinality.lower == 0 and
            self.eContainer.input.cardinality.upper == 1
        message: "Cardinality of 'GET' operation's input parameter must be 0..1"
    }

    constraint GetOperationOutputCardinalityIsValid {
    	guard: self.satisfiesAll("GetOperationOutputParameterIsDefined")
    	check: self.eContainer.output.cardinality.lower == self.owner.cardinality.lower and
    		self.eContainer.output.cardinality.upper == self.owner.cardinality.upper 
    	message: "Cardinality of 'GET' operation's output parameter must be the same as its owner's (operation: " + self.eContainer.name + ")"
    }
}

context PSM!TransferOperationBehaviour {
	
	guard: self.eContainer.isDefined()
		and self.behaviourType == PSM!TransferOperationBehaviourType#DELETE
		and self.satisfiesAll("OperationIsValidUnboundBehaviour","OwnerIsRelationUnboundBehaviour","RelationIsUndefinedUnboundWithoutRelation")
	
	constraint DeleteOperationInputParameterIsDefined {
    	check: self.eContainer.input.isDefined()
    	message: "'DELETE' operation must have an input parameter named 'input' (operation: " + self.eContainer.name + ")"
    }
    
    constraint DeleteOperationInputNameIsValid {
    	guard: self.satisfies("DeleteOperationInputParameterIsDefined")
    	check: self.eContainer.input.name == "input"
    	message: "'DELETE' operation's input parameter must be named 'input' (operation: " + self.eContainer.name + ")"
    }
    
    constraint DeleteOperationInputTypeIsValid {
    	guard: self.satisfies("DeleteOperationInputParameterIsDefined")
    	check: self.eContainer.input.type.equals(self.owner.target)
    	message: "Type of 'DELETE' operation's input parameter must be type of exposed graph's mapped transfer object type (operation: " + self.eContainer.name + ")"
    }
    
    constraint DeleteOperationInputCardinalityIsValid {
    	guard: self.satisfies("DeleteOperationInputParameterIsDefined")
    	check: self.eContainer.input.cardinality.lower == 1 and
    		self.eContainer.input.cardinality.upper == 1 
    	message: "Cardinality of 'DELETE' operation's input parameter must be 1..1 (operation: " + self.eContainer.name + ")"
    }
    
    constraint DeleteOperationOutputParameterIsNotDefined {
    	check: self.eContainer.output.isUndefined()
    	message: "'DELETE' operation cannot have an output parameter (operation: " + self.eContainer.name + ")"
    }
}

context PSM!TransferOperationBehaviour {

	guard: self.eContainer.isDefined() and 
		(self.behaviourType == PSM!TransferOperationBehaviourType#CREATE or
		self.behaviourType == PSM!TransferOperationBehaviourType#UPDATE)
		and self.satisfiesAll("OperationIsValidUnboundBehaviour","OwnerIsRelationUnboundBehaviour","RelationIsUndefinedUnboundWithoutRelation")
		

	 constraint CreateUpdateOperationInputParameterIsDefined {
    	check: self.eContainer.input.isDefined()
    	message: "'" + self.behaviourType + "' operation must have an input parameter named 'input' (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationInputNameIsValid {
    	guard: self.satisfies("CreateUpdateOperationInputParameterIsDefined")
    	check: self.eContainer.input.name == "input"
    	message: "'" + self.behaviourType + "' operation's input parameter must be named 'input' (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationInputTypeIsValid {
    	guard: self.satisfies("CreateUpdateOperationInputParameterIsDefined")
    	check: self.eContainer.input.type.equals(self.owner.target)
    	message: "Type of '" + self.behaviourType + "' operation's input parameter must be type of exposed graph's mapped transfer object type (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationInputCardinalityIsValid {
    	guard: self.satisfies("CreateUpdateOperationInputParameterIsDefined")
    	check: self.eContainer.input.cardinality.lower == 1 and
    		self.eContainer.input.cardinality.upper == 1 
    	message: "Cardinality of '" + self.behaviourType + "' operation's input parameter must be 1..1 (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationOutputParameterIsDefined {
    	check: self.eContainer.output.isDefined()
    	message: "'" + self.behaviourType + "' operation must have an output parameter named 'output' (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationOutputNameIsValid {
    	guard: self.satisfies("CreateUpdateOperationOutputParameterIsDefined")
    	check: self.eContainer.output.name == "output"
    	message: "'" + self.behaviourType + "' operation's output parameter must be named 'output' (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationOutputTypeIsValid {
    	guard: self.satisfies("CreateUpdateOperationOutputParameterIsDefined")
    	check: self.owner.target.equals(self.eContainer.output.type)
    	message: "Type of '" + self.behaviourType + "' operation's output parameter must be exposed graph's mapped transfer object type (operation: " + self.eContainer.name + ")"
    }
    
    constraint CreateUpdateOperationOutputCardinalityIsValid {
    	guard: self.satisfies("CreateUpdateOperationOutputParameterIsDefined")
    	check: self.eContainer.output.cardinality.lower == 1 and
    		self.eContainer.output.cardinality.upper == 1 
    	message: "Cardinality of '" + self.behaviourType + "' operation's output parameter must be 1..1 (operation: " + self.eContainer.name + ")"
    }
}		
