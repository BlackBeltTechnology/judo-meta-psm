//TODO-ask: Should NamedElements' name be unique in whole model? (pbbly not)
context PSM!NamedElement {

    constraint NamedElementHasContainer {
        guard: not self.isKindOf(PSM!Model)
        check: self.eContainer.isDefined()
        message: "Named element " + self.name + " has no container"
    }
    
    constraint NamedElementIsUniqueInItsContainer {
        guard: self.eContainer.isDefined()
        check: not self.eContainer.eContents.select(c | c.isKindOf(PSM!NamedElement) and c <> self).exists(ne | ne.name.toLowerCase() == self.name.toLowerCase())
        message: "Named element " + self.name + " is not unique in its container"
    }
}

context PSM!TransferObjectRelation {

	constraint UnmappedTransferObjectTypeHasNoRelationBinding {
		guard: self.eContainer.isDefined() and self.eContainer.isKindOf(PSM!UnmappedTransferObjectType)
		check: not self.binding.isDefined()
		message: "Transfer object relation " + self.name + " of unmapped transfer object " + self.eContainer().name + " must not have binding."	
	}
	
	constraint TargetMatchesBindingTarget{
        guard:  self.target.isKindOf(MappedTransferObjectType) and self.binding.isDefined()
        check:  self.target.entityType.getAllSuperEntityTypes().including(self.target.entityType).contains(self.binding.target)
        message: "EntityType of mapped transfer object type " + self.target.name + " (target of transfer object relation " + self.name
        			+ ") must match the target of the binding of transfer object relation " + self.name + "."  
    }
    
    constraint CardinalityMatchesBindingCardinality {
        guard:  self.binding.isDefined()
        check:  (self.cardinality.lower == self.binding.cardinality.lower) and
                (self.cardinality.upper == self.binding.cardinality.upper)
        message: "Transfer object relation " + self.name + " and its binding must have the same cardinality."
    }

    constraint TransferObjectRelationIsEmbedded {
        guard: self.target.isKindOf(PSM!UnmappedTransferObjectType)
        check: self.embedded
        message: "Transfer object relation " + self.name + " is referencing to unembedded unmapped transfer object type: " + self.target.name
    }
    
    constraint TransferObjectRelationBindingIsValid {
        guard: self.eContainer().isDefined() and self.eContainer.isKindOf(MappedTransferObjectType) and self.binding.isDefined()
        check:  self.eContainer().entityType.getAllSuperEntityTypes().including(self.eContainer().entityType).contains(self.binding.eContainer()) or
                self.binding.isKindOf(PSM!StaticNavigation) 
        message: "Binding of transfer object relation " + self.name + " of mapped transfer object " + self.eContainer().name +
                " must either match the entity type of the mapped tranfer object or be StaticNavigation."
    }   
}

context PSM!TransferAttribute {

	constraint UnmappedTransferObjectTypeHasNoAttributeBinding {
		guard: self.eContainer.isDefined() and self.eContainer.isKindOf(PSM!UnmappedTransferObjectType)
		check: not self.binding.isDefined()
		message: "Transfer object attribute " + self.name + " of unmapped transfer object " + self.eContainer().name + " must not have binding."
	}
	
    constraint DataTypeMatchesBindingDataType {
        guard:  self.binding.isDefined()
        check:  self.dataType == self.binding.dataType
        message: "DataType of transfer attribute " + self.name + " must match the dataType of its binding."
    }
    
    constraint RequiredFlagMatchesBindingRequiredFlag {
        guard:  self.binding.isDefined()
        check:  self.required == self.binding.required
        message: "Required flag of transfer attribute " + self.name + " must equal required flag of its binding."
    }
    
    constraint TransferAttributeBindingIsValid {
        guard: self.eContainer().isDefined() and self.eContainer.isKindOf(MappedTransferObjectType) and self.binding.isDefined()
        check: self.eContainer().entityType.getAllSuperEntityTypes().including(self.eContainer().entityType).contains(self.binding.eContainer()) or
                self.binding.isKindOf(PSM!StaticData)
        message: "Binding of transfer attribute " + self.name + " of mapped transfer object " + self.eContainer().name +
                " must either match the entity type of the mapped tranfer object or be StaticData."
    }
}

context PSM!ExposedGraph {

    constraint SelectorTargetIsValid {
        check: self.selector.target == self.mappedTransferObjectType.entityType
        message: "Target of selector of exposed graph " + self.name + " must match the entity type of the exposed graph's mapped transfer object."
    }

    constraint SelectorCardinalityIsValid {
        check:  (self.selector.cardinality.lower == self.cardinality.lower) and
                (self.selector.cardinality.upper == self.cardinality.upper)
        message: "Cardinality of exposed graph " + self.name + " must match cardinality of the exposed graph's selector."
    }
}

context PSM!BoundOperation {

    /*constraint BoundOperationOverloadingIsNotSupported {
        guard: self.eContainer().isDefined() and 
               self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                    .select(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase())).size() == 0
        check {
               var op = self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                   .selectOne(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase()))
                   .operations.selectOne(o | o.name.toLowerCase() == self.name.toLowerCase());
               var inputIsValid : Boolean = true;
                   
               return self.input.isDefined() == op.input.isDefined() and
                   self.output.isDefined() == op.output.isDefined() and
                   self.faults.size() == op.faults.size()       
            }
        message: 
    }*/

    constraint BoundOperationInputOverridingIsValid {
        guard: self.eContainer().isDefined() and 
               self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                    .select(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase())).size() == 1
        check {
            var op = self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                .selectOne(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase()))
                .operations.selectOne(o | o.name.toLowerCase() == self.name.toLowerCase());
            var inputIsValid : Boolean = true;

            if (self.input.isDefined()) {
                if (not op.input.isDefined()) {
                    inputIsValid = false;
                } else if (not op.input.type.superTransferObjectTypes.including(op.input.type).contains(self.input.type)) {
                    inputIsValid = false;
                }
            } else if (op.input.isDefined()) inputIsValid = false;
            
            return inputIsValid;
        }
        message: "Overriding of bound operation: " + self.name + " is not valid. Input parameter type of the overriden operation must match or derive from the input parameter."
    }
    
  constraint BoundOperationOutputOverridingIsValid {
        guard: self.eContainer().isDefined() and 
                self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                    .select(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase())).size() == 1
        check {
            var op = self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                .selectOne(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase()))
                .operations.selectOne(o | o.name.toLowerCase() == self.name.toLowerCase());
            var inputIsValid : Boolean = true;
                
            if (self.output.isDefined()){
                if (not op.output.isDefined()) inputIsValid = false;
                    else if (not self.output.type.superTransferObjectTypes.including(self.output.type).contains(op.output.type)) inputIsValid = false;
            } else if (op.output.isDefined()) inputIsValid = false;
            
            return inputIsValid;
        }
        message: "Overriding of bound operation: " + self.name + " is not valid. Output parameter type must match or derive from the output parameter of the overriden operation." 
    }

    constraint BoundOperationFaultsOverridingIsValid {
        guard: self.eContainer().isDefined() and 
                self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                    .select(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase())).size() == 1
        check {
            var op = self.eContainer().superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType))
                .selectOne(t | t.operations.exists(o | o.name.toLowerCase() == self.name.toLowerCase()))
                .operations.selectOne(o | o.name.toLowerCase() == self.name.toLowerCase());
            var inputIsValid : Boolean = true;
                
            if (self.faults.isDefined()) {
                if (not op.faults.isDefined()) { inputIsValid = false; }
                else if (self.faults.size() <> op.faults.size()) { inputIsValid = false;  } 
                else {
                    for (selfFault in self.faults) {
                        if (not op.faults.exists(f | selfFault.type.superTransferObjectTypes.including(selfFault.type).contains(f.type))) { inputIsValid = false; }
                    }
                 }
             } else if (op.faults.isDefined()) {
                inputIsValid = false;
             } 
            
            return inputIsValid;
        }
        message: "Overriding of bound operation: " + self.name + " is not valid. Fault parameter type must match or derive from the fault parameter of the overriden operation." 
    }
}