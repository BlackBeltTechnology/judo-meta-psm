//TODO-ask: Should NamedElements' name be unique in whole model? (pbbly not)
context PSM!NamedElement {

    constraint NamedElementHasContainer {
        guard: not self.isKindOf(PSM!Model)
        check: self.eContainer.isDefined()
        message: "Named element " + self.name + " has no container"
    }
    
    constraint NamedElementIsUniqueInItsContainer {
        guard: self.eContainer.isDefined()
        check: not self.eContainer.eContents.select(c | c.isKindOf(PSM!NamedElement) and c <> self).exists(ne | ne.name.toLowerCase() == self.name.toLowerCase())
        message: "Named element " + self.name + " is not unique in its container"
    }
}

context PSM!TransferObjectRelation {

	constraint UnmappedTransferObjectTypeHasNoRelationBinding {
		guard: self.eContainer.isDefined() and self.eContainer.isKindOf(PSM!UnmappedTransferObjectType)
		check: not self.binding.isDefined()
		message: "Transfer object relation " + self.name + " of unmapped transfer object " + self.eContainer().name + " must not have binding."	
	}
	
	constraint TargetMatchesBindingTarget{
        guard:  self.target.isKindOf(MappedTransferObjectType) and self.binding.isDefined()
        check:  self.target.entityType.getAllSuperEntityTypes().including(self.target.entityType).contains(self.binding.target)
        message: "EntityType of mapped transfer object type " + self.target.name + " (target of transfer object relation " + self.name
        			+ ") must match the target of the binding of transfer object relation " + self.name + "."  
    }
    
    constraint CardinalityMatchesBindingCardinality {
        guard:  self.binding.isDefined()
        check:  (self.cardinality.lower == self.binding.cardinality.lower) and
                (self.cardinality.upper == self.binding.cardinality.upper)
        message: "Transfer object relation " + self.name + " and its binding must have the same cardinality."
    }

    constraint TransferObjectRelationIsEmbedded {
        guard: self.target.isKindOf(PSM!UnmappedTransferObjectType)
        check: self.embedded
        message: "Transfer object relation " + self.name + " is referencing to unembedded unmapped transfer object type: " + self.target.name
    }
    
    constraint TransferObjectRelationBindingIsValid {
        guard: self.eContainer().isDefined() and self.eContainer.isKindOf(MappedTransferObjectType) and self.binding.isDefined()
        check:  self.eContainer().entityType.getAllSuperEntityTypes().including(self.eContainer().entityType).contains(self.binding.eContainer()) or
                self.binding.isKindOf(PSM!StaticNavigation) 
        message: "Binding of transfer object relation " + self.name + " of mapped transfer object " + self.eContainer().name +
                " must either match the entity type of the mapped tranfer object or be StaticNavigation."
    }   
}

context PSM!TransferAttribute {

	constraint UnmappedTransferObjectTypeHasNoAttributeBinding {
		guard: self.eContainer.isDefined() and self.eContainer.isKindOf(PSM!UnmappedTransferObjectType)
		check: not self.binding.isDefined()
		message: "Transfer object attribute " + self.name + " of unmapped transfer object " + self.eContainer().name + " must not have binding."
	}
	
    constraint DataTypeMatchesBindingDataType {
        guard:  self.binding.isDefined()
        check:  self.dataType == self.binding.dataType
        message: "DataType of transfer attribute " + self.name + " must match the dataType of its binding."
    }
    
    constraint RequiredFlagMatchesBindingRequiredFlag {
        guard:  self.binding.isDefined()
        check:  self.required == self.binding.required
        message: "Required flag of transfer attribute " + self.name + " must equal required flag of its binding."
    }
    
    constraint TransferAttributeBindingIsValid {
        guard: self.eContainer().isDefined() and self.eContainer.isKindOf(MappedTransferObjectType) and self.binding.isDefined()
        check: self.eContainer().entityType.getAllSuperEntityTypes().including(self.eContainer().entityType).contains(self.binding.eContainer()) or
                self.binding.isKindOf(PSM!StaticData)
        message: "Binding of transfer attribute " + self.name + " of mapped transfer object " + self.eContainer().name +
                " must either match the entity type of the mapped tranfer object or be StaticData."
    }
}

context PSM!ExposedGraph {

    constraint SelectorTargetIsValid {
        check: self.selector.target == self.mappedTransferObjectType.entityType
        message: "Target of selector of exposed graph " + self.name + " must match the entity type of the exposed graph's mapped transfer object."
    }

    constraint SelectorCardinalityIsValid {
        check:  (self.selector.cardinality.lower == self.cardinality.lower) and
                (self.selector.cardinality.upper == self.cardinality.upper)
        message: "Cardinality of exposed graph " + self.name + " must match cardinality of the exposed graph's selector."
    }
}

context PSM!BoundOperation {
    
    constraint OverridingWithValidInput {
        guard: self.eContainer().isDefined() and self.input.isDefined()
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | o.input.isDefined() and o.input.type == self.input.type)
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change input type."
    }
    
    constraint OverridingWithValidInput {
        guard: self.eContainer().isDefined() and (not self.input.isDefined())
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | not o.input.isDefined())
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change input type."
    }
    
    constraint OverridingWithValidOutput {
        guard: self.eContainer().isDefined() and self.output.isDefined()
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | o.output.isDefined() and o.output.type == self.output.type)
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change output type."
    }
    
    constraint OverridingWithValidOutput {
        guard: self.eContainer().isDefined() and (not self.output.isDefined())
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | not o.output.isDefined())
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change output type."
    }
    
    constraint OverridingWithValidFaults {
        guard: self.eContainer().isDefined() and self.faults.size() == 0
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | o.faults.size() == 0)
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change the type of faults."
     }
     
     constraint OverridingWithValidFaults {
        guard: self.eContainer().isDefined() and self.faults.size() > 0
        check: self.eContainer().getAllSuperTransferObjectTypes().collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                .forAll(o | self.faults.size() == o.faults.size() and 
                            o.faults.collect(f | f.type.name).sortBy(n | n).equals(self.faults.collect(f | f.type.name).sortBy(n | n)) )
        message: "Overriding of bound operation: " + self.name + " of mapped transfer object type: " + self.eContainer().name + " cannot change the type of faults."
     }
     
     constraint InheritedBoundOperationHasNoImplementation {
        guard: self.eContainer().isDefined()
        check: (not self.implementation.isDefined()) implies
               (not self.eContainer().getAllSuperTransferObjectTypes()
                    .select(t | t.isKindOf(PSM!MappedTransferObjectType))
                    .collect(t | t.operations.select(o | o.name.toLowerCase() == self.name.toLowerCase())).flatten()
                    .exists(o | o.implementation.isDefined()))
        message: "Bases of bound operation: " + self.name + " cannot have implementation, if " + self.name + " in mapped transfer object type: "
                    + self.eContainer().name + " doesn't have one."
    }
}