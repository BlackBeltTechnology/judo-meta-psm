context PSM!Primitive {
    // primitive type names should be unique
    critique PrimitiveTypeNamesAreUnique {
        check: not PSM!Primitive.all.excluding(self).selectOne(t | t.name.toLowerCase() == self.name.toLowerCase()).isDefined()
        message: "Primitive type name is not unique: " + self.name
    }
}

context PSM!TransferObjectType {
    // transfer object type names should be unique
    critique TransferObjectTypeNamesAreUnique {
        check: not PSM!TransferObjectType.all.excluding(self).selectOne(t | t.name.toLowerCase() == self.name.toLowerCase()).isDefined()
        message: "Transfer object type name is not unique: " + self.name
    }
    
    constraint InheritedBoundOperationNamesAreUnique {
        guard: self.isKindOf(PSM!MappedTransferObjectType)
        check {
            var uniqueNames = new Set;
            var duplicateNames = new Sequence;
            var operations = new Sequence;
            var baseTypes = new Sequence;
            baseTypes.addAll(self.superTransferObjectTypes.select(t | t.isKindOf(PSM!MappedTransferObjectType)));
            for (base in baseTypes) {
                operations.addAll(base.operations);
                for (op in operations) {
                    for (name in uniqueNames) {
                        if(name.toUpperCase() == op.name.toUpperCase()) {
                            duplicateNames.add(op.name);
                        }
                    }
                    uniqueNames.add(op.name);
                }
                operations.clear();
            }
            return duplicateNames.isEmpty();
        }
        message: "Mapped transfer object type " + self.name + " has inherited bound operations with the same name."
    }
}



